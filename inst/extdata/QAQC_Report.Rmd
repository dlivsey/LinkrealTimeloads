---
output:
  html_document: default
params:
  author: ""
  user_data_folder: !r paste0(gsub('Documents','Desktop',file.path(path.expand('~'))),'/LinkreaTimeloads_Output')
  site_folder: JRI
  site_name: Johnstone River at Innisfail
  compute_from_time: !r Sys.Date()-365*3
  compute_to_time: !r Sys.Date()
  max_points: 30
---

---
title: `r paste('QAQC report for',params$site_name)`
date: "`r format(Sys.time(), '%d %B %Y')`"
author: `r params$author`
---


```{r setup, include=FALSE, results = 'hide'}
knitr::opts_chunk$set(echo = TRUE,
                      warning = FALSE,
                      message = FALSE)
# libraries 
library(plotly)
library(ggplot2)
library(dygraphs)
library(xts)

user_data_folder <- params$user_data_folder
site <- params$site_folder
if (params$compute_to_time==Sys.Date()) {
period <- as.POSIXct(c(params$compute_from_time,params$compute_to_time),tz='Australia/Brisbane')-60*60*10 # minus 10 hours since Sys.Date() reports in UTC
}
if (params$compute_to_time!=Sys.Date()) {
period <- as.POSIXct(c(params$compute_from_time,params$compute_to_time),tz='Australia/Brisbane') # assume given dates are in AEST 
}

max_points <- params$max_points

```

This file contains key plots for initial QA/QC of suspended-sediment concentration (TSS), discharge (Q), and loads() generated by LinkrealTimeloads. The report was generated by LinkrealTimeloads::QAQC_Report()

## Timeseries (TSS, Discharge, Load, and Cumulative Load)

The upper panel below shows timeseries of TSS and discharge used to compute suspended-sediment load for the time period indicated by the user in "compute_from_time" and "compute_to_time"

The lower panel below shows timeseries of instantaneous and cumulative Load in kilotons (kt) computed from the product of TSS and discharge for the time period indicated by the user in "period". Note that load can be "negative" because of the product of upstream tidal flow (negative discharge) to TSS. An advantage of using continous estimates of TSS is that one can capture upstream sediment load. For some estuaries, especially in the dry season, sediment transport may be net upstream (i.e., negative cumulative load). 

The plots are interactive and linked with time. The lower sub-panels can be used to zoom and pan across the timeseries. Anomalies in the data can be caused by errors in turbidity, acoustic backscatter, or imputation. Workers should visually inspect the timeseries and remove data as needed. 

```{r TSS, echo=FALSE,fig.dim = c(3, 1),dpi=300}

### Upper panel ----

# Load data used to compute Loads
Loads <- readRDS(paste0(user_data_folder,'/',site,'/Loads.rds'))
# Get site name for plotting from Site.rds
Site <- readRDS(paste0(user_data_folder,"/Site_List.rds"))
Site <- Site[Site$Site_Folder==site,] 


if (length(period)==0) {
  period <- Loads[["Total_load_time_period"]]
}

ind <- Loads$time>=min(period) & Loads$time<=max(period)

# data frame for plotting, note order of variables is important, first column is the first y axis, and so on...
data <- data.frame(TSS = Loads$TSS_mg_per_liter$median_confidence[ind], Q = Loads$Discharge_m3_per_sec[ind])

# Range of variables for plotting, can be used in dyAxis(valueRange = y1r) but seems to remove auto-scaling when panning 
#y1r <- c(floor(min(data[,1],na.rm = TRUE))*0.9,ceiling(max(data[,1],na.rm = TRUE))*1.1)
#y2r <- c(floor(min(data[,2],na.rm = TRUE))*1.1,ceiling(max(data[,2],na.rm = TRUE))*1.1)

# z timeseries object for dygraph()
zts <- xts(data,order.by = Loads$time[ind])

# Create plot
# see examples from: https://rstudio.github.io/dygraphs/gallery-axis-options.html for help making plots in dygraph

# data in last call to dyAxis is plotted on top
p <- dygraph(zts,main = Site$Site_Name, group = "timeseries") %>%
  dyOptions(labelsUTC = FALSE, fillGraph=FALSE, fillAlpha=0.1, drawGrid = FALSE,pointSize = 2,drawPoints = TRUE) %>%
  dyAxis("y2", label = "Discharge (Q) (m<sup>3</sup>/s) ", independentTicks = TRUE) %>%     
  dySeries("Q", axis=('y2'),color = "blue") %>%
  dyAxis("y", label = "TSS (mg/l)", independentTicks = TRUE)%>%
  dySeries("TSS", axis=('y'),color = "red") %>%
  dyRangeSelector(fillColor = "") %>%
  dyCrosshair(direction = "vertical") %>%
  dyHighlight(highlightCircleSize = 5, highlightSeriesBackgroundAlpha = 0.8,highlightSeriesOpts = list(strokeWidth = 2), hideOnMouseOut = FALSE)
 

### Lower panel ----

# data frame for plotting, note order of variables is important, first column is the first y axis, and so on...
# compute cumulative Load timeseries, cumsum() will not work w/ NA
# replace NA w/ zeros and then use change in load == 0 to set cLoad to NA for plotting purposes 
cLoad <- Loads$Load_kt$median_confidence[ind]
cLoad[is.na(cLoad)] <- 0
cLoad <- cumsum(cLoad)
cLoad[c(1,diff(cumsum(cLoad)))==0] <- NA

data <- data.frame(Load = Loads$Load_kt$median_confidence[ind], Cumulative_Load = cLoad)

# Range of variables for plotting, can be used in dyAxis(valueRange = y1r) but seems to remove auto-scaling when panning 
#y1r <- c(floor(min(data[,1],na.rm = TRUE))*0.9,ceiling(max(data[,1],na.rm = TRUE))*1.1)
#y2r <- c(floor(min(data[,2],na.rm = TRUE))*1.1,ceiling(max(data[,2],na.rm = TRUE))*1.1)

# z timeseries object for dygraph()
zts <- xts(data,order.by = Loads$time[ind])

# Create plot
# see examples from: https://rstudio.github.io/dygraphs/gallery-axis-options.html for help making plots in dygraph
# data in last call to dyAxis is plotted on top
p2 <- dygraph(zts,main = '', group = "timeseries") %>%
  dyOptions(labelsUTC = FALSE, fillGraph=FALSE, fillAlpha=0.1, drawGrid = FALSE,pointSize = 2,drawPoints = TRUE) %>%
  dyAxis("y", label = "Load (kt)", independentTicks = TRUE)%>%
  dySeries("Load", axis=('y'),color = "green") %>%
  dyRangeSelector(fillColor = "") %>%
  dyCrosshair(direction = "vertical") %>%
  dyAxis("y2", label = "Cumulative Load (kt)", independentTicks = TRUE) %>%     
  dySeries("Cumulative_Load", axis=('y2'),color = "black") %>%
  dyHighlight(highlightCircleSize = 5, highlightSeriesBackgroundAlpha = 0.8,highlightSeriesOpts = list(strokeWidth = 2), hideOnMouseOut = FALSE)

### Plots ----
p

p2

```


## Kt estimates used to predict TSS

The prediction of TSS from acoustic backscatter and turbidity per Livsey et al (2023, https://doi.org/10.1029/2022WR033982) is summarized below. Firstly, a generalized linear model is used to regress Kt(SCI,Period) where: 

* Kt = dB - 10*log10(TSS) (decibels)
* dB is acoustic backscatter processed from the ADCP (decibels)
* TSS is total suspended-solids (mg/l)
* SCI = dB - 10*log10(Turbidity)(decibels)
* Turbidity measured from an optical backscattering sensor (e.g., EXO) (FNU)
* period is a categorical variable indicating when ADCP instrument, settings, and elevation where held constant (factor)

With timeseries estimates of "Kt" from the "Sediment Composition Index" (SCI), TSS timeseries is be computed via TSS = 0.1dB - 0.1Kt(SCI,period). Details for this approach are given in Livsey et al (2023). "Kt" in linear units is the ratio of acoustic backscatter to TSS for a given instrument and suspension of particles. By predicting Kt from SCI, changes in particle size across events can be accounted for when estimating TSS from ADCP.

The addition of "period" as a categorical variable allows data across periods to be pooled since Kt(SCI) depends on ADCP instrument, settings, and elevation. "period" is simply the row number read from ADCP_Setting_Summary_Table.rds in site/ADCP_data/ADCP_Setting_Summary_Table.rds where each row indicates time periods when the ADCP instrument, settings, and elevation are held constant. This approach allows all Kt(SCI) data to be combined into a single generalized linear model of Kt(SCI,period).

The file "TSS_estimated_from_SCI_with_metadata.rds" in site/Analyte_data is generated by Predict_TSS_from_SCI() and provides timeseries estimates of TSS along with all data used in the regression of Kt(SCI,period)

Below a plot of Kt(SCI,period) is provided along with timeseries Kt estimated from Kt(SCI,period). Note that Kt often varies tidally and through discharge events. If TSS was estimated from dB alone, Kt would be held-constant as the intercept of TSS(dB). Local calibration between SCI and in-situ particle size can be undertaken to estimated suspended-sediment loads delineated by particle size (see details in Livsey et al (2023))

All plots are interactive. Data for each period in the scatter plot can be made invisible or visible by clicking on the respective legend icon. The parameter "max_points" in QAQC_Report limits the number of points to plot per period. If a period has data exceeding "max_points", "max_points" are randomly sampled. "max_points" can be set to Inf to plot all data from all periods. 

```{r Regression, echo=FALSE,fig.dim = c(2, 2),dpi=300}

### scatter plot ----
estTSS <- readRDS(paste0(user_data_folder,'/',site,'/Analyte_data/TSS_estimated_from_SCI_with_metadata.rds'))

regr <- estTSS$Kt_predicted_from_SCI$regression_data$regression_data

ind2 <- regr$time>=min(period) & regr$tim<=max(period)

ind2 <- regr$time>=regr$time[1]

# gets list of periods
periods <- as.integer(levels(unique(regr$period[ind2])))

# for any period only plot up-to max_points 
ind3 <- list()
for (i in 1:length(periods)) {
ind3[[i]] <- which(regr$period[ind2]==periods[i])

if (length(ind3[[i]])>max_points) {
  ind3[[i]] <- sample(ind3[[i]],max_points)
}

}

ind4 <- unique(unlist(ind3))
    
data <- data.frame(kt = regr$kt[ind4],sci = regr$sci[ind4],period = regr$period[ind4])

p3 <- ggplot(data, aes(kt, sci))
p3 <-  p3 + geom_point(aes(colour = factor(period),shape = factor(period))) 

# plot ggplot in interactive mode using plotly 
ggplotly(p3)

```

```{r Kt, echo=FALSE,fig.dim = c(3, 1),dpi=300}
### timeseries plot ----

# data frame for plotting, note order of variables is important, first column is the first y axis, and so on...

# likely not needed in most cases but estTSS and Loads may be on different time in some instances 
Kt <- realTimeloads::linear_interpolation_with_time_limit(estTSS$Kt_predicted_from_SCI$time,estTSS$Kt_predicted_from_SCI$estimated_timeseries_quantiles$median_confidence,Loads$time[ind],10/60)$x_interpolated

data <- data.frame(Kt, Q = Loads$Discharge_m3_per_sec[ind])

# Range of variables for plotting, can be used in dyAxis(valueRange = y1r) but seems to remove auto-scaling when panning 
#y1r <- c(floor(min(data[,1],na.rm = TRUE))*0.9,ceiling(max(data[,1],na.rm = TRUE))*1.1)
#y2r <- c(floor(min(data[,2],na.rm = TRUE))*1.1,ceiling(max(data[,2],na.rm = TRUE))*1.1)

# z timeseries object for dygraph()
zts <- xts(data,order.by = Loads$time[ind])

# Create plot
# see examples from: https://rstudio.github.io/dygraphs/gallery-axis-options.html for help making plots in dygraph

# data in last call to dyAxis is plotted on top
p4 <- dygraph(zts,main = Site$Site_Name, group = "timeseries") %>%
  dyOptions(labelsUTC = FALSE, fillGraph=FALSE, fillAlpha=0.1, drawGrid = FALSE,pointSize = 2,drawPoints = TRUE) %>%
  dyAxis("y2", label = "Discharge (Q) (m<sup>3</sup>/s) ", independentTicks = TRUE) %>%     
  dySeries("Q", axis=('y2'),color = "blue") %>%
  dyAxis("y", label = "Kt (dB)", independentTicks = TRUE)%>%
  dySeries("Kt", axis=('y'),color = "red") %>%
  dyRangeSelector(fillColor = "") %>%
  dyCrosshair(direction = "vertical") %>%
  dyHighlight(highlightCircleSize = 5, highlightSeriesBackgroundAlpha = 0.8,highlightSeriesOpts = list(strokeWidth = 2), hideOnMouseOut = FALSE)

# plot timeseries 
p4


#'https://bookdown.org/yihui/rmarkdown/params-knit.html'

```




