#' Saves or updates "ADCP_Setting_Summary_Table.rds" in user_data_folder/site/ADCP_dat. Called in Link_to_Real_time_loads()
#'
#' Generates ADCP_Setting_Summary_Table.rds from rds files generated by Import_Channelmaster_Data(). ADCP_Setting_Summary_Table.rds is used for processing in Predict_TSS_from_SCI()
#'
#' @param user_data_folder file path to user data folder
#' @param site site folder under user_data_folder
#' @note
#' All functions expect data to be in following folders:
#'
#' \describe{
#'   \item{1. user_data_folder/site/ADCP_data}{- Place 000 files here}
#'    }
#' \describe{
#'   \item{2. user_data_folder/site/Analyte_data}{- Place TSS data from EAGLE IO csv export here}
#'    }
#'    \describe{
#'   \item{3. user_data_folder/site/Channel_Geometry}{- Place cross-section survety in xs.RDS file format from Stephen Wallace here}
#'    }
#'    \describe{
#'   \item{4. user_data_folder/site/Discharge_data }{- Place discharge and velocity csv files from Stephen Wallace here}
#'    }
#'    \describe{
#'   \item{5. user_data_folder/site/Height_Offsets}{- Place height offset data from EAGLE IO csv export here}
#'    }
#'    \describe{
#'   \item{6. user_data_folder/site/Sonde_and_Height_data}{- Place TSS data from EAGLE IO csv export here}
#'    }
#'
#' Where "site" is a specific site (e.g., for Johnstone at Innisfail use site <- "JRI")
#'
#' See vignette('LinkrealTimeloads') for further instructions
#'
#' @return ADCP setting summary table used for processing in Predict_TSS_from_SCI.R. Output written to site/ADCP_data/Processed_Backscatter_data.rds
#' @seealso
#' \code{\link{Link_to_Real_time_loads}} Process data in specified folder structure using realTimeloads package
#'
#' @author Daniel Livsey (2023) ORCID: 0000-0002-2028-6128
#' @examples
#' # See vignette('LinkrealTimeloads',package = LinkrealTimeloads)
#' @references
#' Stephen Wallace (2023, DES) provided crucial functions in Import_Channelmaster_Data() to extract data from binary 000 files.
#'
#' Livsey D.N. (2023). realTimeloads: Analyte Flux and Load from Estimates of Concentration and Discharge_. R package version 1.0.0.
#'
#' Livsey, D.N. (in review). National Industry Guidelines for hydrometric monitoringâ€“Part 12: Application of acoustic Doppler velocity meters to measure suspended-sediment load. Bureau of Meteorology. Melbourne, Australia
#'
#' @export
ADCP_Setting_Summary_Table <- function(user_data_folder,site = NULL) {
  # user_data_folder where all site folders are located
  # site: site folder:
  # process data in specific site folder if desired, otherwise processes all data by site in user_data_folder
  # saves or updates "ADCP_Setting_Summary_Table.rds" in user_data_folder\site\ADCP_data
  # table provides periods in which ADCP settings are held constant and regression between backscatter and TSS should not vary due to instrument setting changes


all_site_folders <- list.dirs(user_data_folder,recursive = "FALSE")

  # get specific site folder if site_folder is provided
  if (!is.null(site)) {
    all_site_folders <- all_site_folders[grepl(site,all_site_folders)]
  }


number_of_sites <- length(all_site_folders)

Site_List <- readRDS(paste0(user_data_folder,'/Site_List.rds'))

for (k in 1:number_of_sites) {
  z<- strsplit(all_site_folders[k],'/')
  site <- z[[1]][length(z[[1]])]

  site_folder <- all_site_folders[k]
  ADCP_folder <- paste0(site_folder,"/ADCP_data")
  Sonde_and_Height_folder <- paste0(site_folder,"/Sonde_and_Height_data")
  Height_offset_folder <- paste0(site_folder,"/Height_Offsets")

  # Load data
  ADCP <- readRDS(paste0(ADCP_folder,"/All_ADCP_Programming_Data.rds"))
  Offsets <- readRDS(paste0(Height_offset_folder,"/Height_Offsets.rds"))
  #

  # Find time periods and files of unique combinations of location, instrument, and cell settings
  vars<-c("Site_number","Instrument_serial_number","CPU_serial_number","Number_of_Cells","Bin_Size_m","Blanking_distance_m","ADCP_elevation_above_gauge_datum_m")
  Periods <- unique(ADCP[vars])
  # add site name
  Site_Name <- rep(Site_List$Site_Name[Site_List$Site_Number==Periods$Site_number[1]],nrow(Periods))
  Periods <- cbind(data.frame(Site_Name),Periods)  # add site name
  # lazy preallocation to order vars in Periods
  Periods$Thalweg_elevation_above_gauge_datum_m_at_Start_time <- NA
  Periods$Thalweg_elevation_above_gauge_datum_m_at_End_time <- NA
  Periods$Start_time <- ADCP$time[1]
  Periods$End_time <- ADCP$time[1] # lazy preallocation
  Periods$Duration_Years <- 0
  Periods$Duration_Days <- 0
  for (i in 1:nrow(Periods)) {
    # get indices of files with unique settings

    # files with unique settings have time after default time of instrument
    ind <- ADCP$Site_number == Periods$Site_number[i] & ADCP$Instrument_serial_number == Periods$Instrument_serial_number[i] & ADCP$CPU_serial_number == Periods$CPU_serial_number[i] & ADCP$Number_of_Cells == Periods$Number_of_Cells[i] & ADCP$Bin_Size_m == Periods$Bin_Size_m[i] & ADCP$Blanking_distance_m == Periods$Blanking_distance_m[i] & ADCP$ADCP_elevation_above_gauge_datum_m == Periods$ADCP_elevation_above_gauge_datum_m[i] & ADCP$time > "2005-01-01 00:00:00"

    # files with unique settings that have time set to default time of instrument
    # allows identification of location of missing data files
    ind_of_files_with_wrong_timestamp <- ADCP$Site_number == Periods$Site_number[i] & ADCP$Instrument_serial_number == Periods$Instrument_serial_number[i] & ADCP$CPU_serial_number == Periods$CPU_serial_number[i] & ADCP$Number_of_Cells == Periods$Number_of_Cells[i] & ADCP$Bin_Size_m == Periods$Bin_Size_m[i] & ADCP$Blanking_distance_m == Periods$Blanking_distance_m[i] & ADCP$ADCP_elevation_above_gauge_datum_m == Periods$ADCP_elevation_above_gauge_datum_m[i] & ADCP$time < "2005-01-01 00:00:00"

    if (sum(ind)==0) ind <- ind_of_files_with_wrong_timestamp # all files are set to default time of instrument

    # Get thalweg depth at start and end of period
    zt<- ADCP$time[ind]
    zThalweg <- ADCP$Thalweg_relative_to_gauge_datum_m[ind]
    zdf <- data.frame(zt,zThalweg)
    zdf <- zdf[order(zdf$zt),]
    Periods$Thalweg_elevation_above_gauge_datum_m_at_Start_time[i] <- zdf$zThalweg[1]
    Periods$Thalweg_elevation_above_gauge_datum_m_at_End_time[i] <- zdf$zThalweg[nrow(zdf)]
    rm(zt,zThalweg,zdf) # remove temporary variables

    # get period start, end, and duration
    Periods$Start_time[i] <- min(ADCP$time[ind])
    Periods$End_time[i] <- max(ADCP$time[ind])
    Periods$Duration_Years[i] <- round(as.numeric(difftime(max(ADCP$time[ind]),min(ADCP$time[ind]),units='days'))/365,2)
    Periods$Duration_Days[i] <- round(as.numeric(difftime(max(ADCP$time[ind]),min(ADCP$time[ind]),units='days')))

    # save file names for later loading/inspection

    # files with unique settings have time after default time of instrument
    if (sum(ind)!=sum(ind_of_files_with_wrong_timestamp)) {
      Periods$files[i] <- list('files'=unique(ADCP$file[ind]))
      Periods$files_with_2004_timestamp[i] <- list("files"=c(NA))
      # check for files that share the same settings but have default time of instrument
      # can be used to help user find missing data files
      if (sum(ind_of_files_with_wrong_timestamp)>0) {
        Periods$files[i] <- list('files'=unique(ADCP$file[ind_of_files_with_wrong_timestamp]))
      }
    }

    # all files with unique settings have default time of instrument
    if (sum(ind)==sum(ind_of_files_with_wrong_timestamp)) {
      Periods$files[i] <- list("files"=c("All files have 2004 timestamp"))
      Periods$files_with_2004_timestamp[i] <- list('files'=unique(ADCP$file[ind]))
    }
  }
  Periods <- Periods[order(Periods$Start_time),]
  row.names(Periods) <- 1:nrow(Periods)

  file<- paste0(ADCP_folder,'/ADCP_Setting_Summary_Table.rds')
  if (!file.exists(file)) saveRDS(Periods,file)
  if (file.exists(file)) {
    po <- readRDS(file)
    df<-rbind(Periods,po)
    row.names(df) <- 1:nrow(df)
    df <- unique(df)
    df <- df[order(df$Start_time),]
    df_out <- df
    # for each row in df check for other rows with same settings and merge file list as needed
    if (nrow(df)!=nrow(unique(df[vars]))) {
      ind <- list()
      for (j in 1:nrow(df)) {

        ind[[j]] <- vector('logical',nrow(df))
        for (k in 1:nrow(df)) {
          if (sum(df[j,vars]==df[k,vars])==length(vars)) ind[[j]][k] <- TRUE
        }
      }
      dfn2<-df
      for (j in 1:nrow(df)) {
        dfn2$files[j][[1]] <- unique(do.call(rbind,(dfn2$files[ind[[j]]])))
        dfn2$files_with_2004_timestamp[j][[1]] <- unique(do.call(rbind,(dfn2$files_with_2004_timestamp[ind[[j]]])))
      }
      df_out <- unique(dfn2)
      saveRDS(df_out,file)
    }

  }

}

}
